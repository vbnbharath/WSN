#include <msp430.h> // Base header files
#include <stdint.h> // pull in standard datatypes
#include <pinDefs.h> // Pin defines
#include <Spi_Library.h> // SPI control for the radio
#include <CC110l.h> // Literals for helping with the radio

#define transmitter
/*
 * main.c
 */

// Stuff specific to the value line boards
#ifdef __MSP430G2553__
static inline void BoardInitValue(void);
static inline void TimerInitValue(void);
#endif
static inline void Radio_Init(void);

volatile uint8_t statusVal[10];

int main(void)
{
// Value line inits
#ifdef __MSP430G2553__
	BoardInitValue();
	TimerInitValue();
#endif

	SPI_Init(); // Start SPI
	Radio_Init(); // Prep the radio

#ifdef receiver

	SPI_Strobe(SRX, Get_RX_FIFO);// Clear RX FIFO


	__bis_SR_register(LPM3_bits + GIE);

    return 0; // Never get here
#endif

#ifdef transmitter

    __bis_SR_register(LPM3_bits + GIE); // Go to sleep
    return 0;
#endif
}

/**************************************************************************
 * Static inlines
 */

#ifdef __MSP430G2553

static inline void BoardInitValue()
{
	WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer

	// Clock setup
	DCOCTL = CALDCO_1MHZ;
	BCSCTL1 = CALBC1_1MHZ;
	BCSCTL2 = SELM_0; // Source MCLK and SMCLK from DCO
	BCSCTL3 = LFXT1S_2; // Use VLO for slow clock

	// Default pinsets for low power consumption

	// Set the default output to low
	P1OUT = BIT0;
	P2OUT = 0;
	P3OUT = 0;

	// Set the direction to out
	P1DIR = 0xFF;
	P2DIR = 0xFF;
	P3DIR = 0XFF;

	// Set the mode of all ports to IO
	P1SEL = 0;
	P1SEL2 = 0;
	P2SEL = 0;
	P2SEL2 = 0;
	P3SEL = 0;
	P3SEL2 = 0;

#ifdef transmitter
	P1REN = BIT3;
	P1DIR &= ~BIT3;
	P1OUT |= BIT3;
	P1IFG &= ~BIT3;
	P1IE |= BIT3;
#endif
}

static inline void TimerInitValue()
{
	// Timer A0 Slow Clock
	TACTL = TASSEL_1 + MC_0; // Set timer A source to SMCLK and stop the clock
	TAR = 0; // Initial count value is 0
	TACCR0 = 11999; // Count up to 12,000
	TACCTL0 = CCIE; // Enable interrupt on TACCR0
	TACTL |= MC_1; // Start counting up to TACCR0

	// Timer A1 Fast Clock
	TA1CTL = TASSEL_2 + MC_0;
	TA1R = 0;
	TA1CCR0 = 49999; // Count up to 50000
	TA1CCTL0 = CCIE; // Enable interrupt on timer TA1CCR0
	TA1CTL |= MC_1; // Start counting up to TACCR0

}
#endif

static inline void Radio_Init()
{
	SPI_Strobe(SRES, Get_RX_FIFO); // Reset radio

	//
	// Rf settings for CC110L, generated by SmartRF Studio
	// This is the very bottom option on the dropdown list
	// 250 kBaud, Dev.: 127 kHz, Mod.: GFSK, RX BW: 540 kHz
	SPI_Send(GDO_RX,0x07 | BIT6);		 //Set GDO_RX to assert on packet RX, active HI
	SPI_Send(PKTCTRL0,0x05);     //Packet Automation Control
	SPI_Send(PKTCTRL1,BIT2 | BIT3);	// Append RSSI and CRC and enable autoflush of bad pkts
	SPI_Send(FSCTRL1,0x12);      //Frequency Synthesizer Control
	SPI_Send(FREQ2,0x21);        //Frequency Control Word, High Byte
	SPI_Send(FREQ1,0x62);        //Frequency Control Word, Middle Byte
	SPI_Send(FREQ0,0x76);        //Frequency Control Word, Low Byte
	SPI_Send(MDMCFG4,0x2D);      //Modem Configuration
	SPI_Send(MDMCFG3,0x3B);      //Modem Configuration
	SPI_Send(MDMCFG2,0x93);      //Modem Configuration
	SPI_Send(DEVIATN,0x62);      //Modem Deviation Setting
	SPI_Send(MCSM0,0x18);        //Main Radio Control State Machine Configuration
	SPI_Send(FOCCFG,0x1D);       //Frequency Offset Compensation Configuration
	SPI_Send(BSCFG,0x1C);        //Bit Synchronization Configuration
	SPI_Send(AGCCTRL2,0xC7);     //AGC Control
	SPI_Send(AGCCTRL1,0x00);     //AGC Control
	SPI_Send(AGCCTRL0,0xB0);     //AGC Control
	SPI_Send(0x20,0xFB);		 //Use setting from SmartRF Studio
	SPI_Send(FREND1,0xB6);       //Front End RX Configuration
	SPI_Send(FSCAL3,0xEA);       //Frequency Synthesizer Calibration
	SPI_Send(FSCAL2,0x2A);       //Frequency Synthesizer Calibration
	SPI_Send(FSCAL1,0x00);       //Frequency Synthesizer Calibration
	SPI_Send(FSCAL0,0x1F);       //Frequency Synthesizer Calibration
	SPI_Send(TEST0,0x09);        //Various Test Settings

#ifdef receiver
	MSP_RX_Port_IFG &= ~MSP_RX_Pin;	// Clear existing interrupt
	MSP_RX_Port_IE |= MSP_RX_Pin;	// Enable interrupt on
#endif
}

/**************************************************************************
 * Interrupt service routuines
 */

// Slow timer ISR
void __attribute__((__interrupt__(TIMER0_A0_VECTOR))) Timer1_A0_ISR(void)
{
	TACCTL0 &= ~CCIFG; // Clear the interrupt flag
	LPM3_EXIT; // Wake up!
}

void __attribute__((__interrupt__(TIMER1_A0_VECTOR))) Timer1_A1_ISR(void)
{
	static int i = 0;

	TA1CCTL0 &= ~CCIFG; // Clear the interrupt flag

	if(i >= 20)
	{
		LED2Reg ^= LED2;
		i=0;
	}
	else
	{
		i++;
	}
}

void __attribute__((__interrupt__(MSP_RX_Port_IV))) MSP_RX_ISR(void)
{
    volatile uint8_t testVal[64];
	volatile uint8_t bytes_in_FIFO;
	volatile uint8_t rBytesVal;

	MSP_RX_Port_IFG &= ~MSP_RX_Pin;

	rBytesVal = SPI_Strobe(SNOP, Get_RX_FIFO);
	bytes_in_FIFO = rBytesVal & FIFO_Bytes;

	statusVal[2] = SPI_Read_Burst(RXFIFO, testVal, bytes_in_FIFO);
	SPI_Strobe(SIDLE, Get_RX_FIFO); // start RX again
	__delay_cycles(1000000);
	SPI_Strobe(SRX, Get_RX_FIFO); // start RX again

	P1OUT ^= BIT0;
}

void __attribute__((__interrupt__(PORT1_VECTOR))) Button_ISR(void)
{
	uint8_t pinState;
	volatile uint8_t status;
	P1IFG &= ~BIT3; // Clear interrupt flag

	pinState = P1IN & BIT3;
	__delay_cycles(100);

	if(pinState == (P1IN & BIT3))
		{
			SPI_Send(TXFIFO, 0x01);
			SPI_Send(TXFIFO, 0xFF);
			status = SPI_Strobe(STX, Get_TX_FIFO);
		}
}
